import 'dart:io';

const String baseMap = ''''''
    '''0000000'''
    '''0000000'''
    '''0000000'''
    '''0001000'''
    '''0000000'''
    '''0000000'''
    '''0000000''';

const String reachabilityMaskstr = ''''''
    '''1011101'''
    '''1010101'''
    '''1010101'''
    '''1010101'''
    '''1010101'''
    '''1010101'''
    '''1110111''';

const int size = 7;

const horizontalKernel = 7; // 111
const horizontalEdgeKernel = 3; // 011
const verticalKernel = 1 | (1 << size) | (1 << (size * 2));
const verticalEdgeKernel = 1 | (1 << size);

void main() {
  runExample2();
  codegen();
  return;
}

void codegen() {
  final File file = new File('./src/duck/Pathfinder.java');

  if (file.existsSync()) {
    file.deleteSync();
  }

  file.createSync();

  const template = ''
      '''// Automagically generated by generate_pathfinder.dart, do not edit by hand.'''
      '\n\n'
      'package duck;'
      '\n\n'
      'public final class Pathfinder { '
      '<BASE_DISTANCE_MAP/>\n\n'
      '\n'
      '<GET_DISTANCES_FN/>'
      '\n'
      'public static void printDistances(int[] distances) {'
      'for (int y = 0; y < $size; y++) {\n'
      'String row = "";'
      'for (int x = 0; x < $size; x++) {\n'
      'int index = y * $size + x;\n'
      'if (distances[index] < 10 && distances[index] >= 0) {\n'
      'row += " ";\n'
      '}\n'
      'row += distances[index] + " ";\n'
      '}\n'
      'System.out.println(row);\n'
      '}\n'
      '}\n'
      '\n'
      'public static void printMask(long mask) {'
      'for (int y = 0; y < $size; y++) {\n'
      'String row = "";'
      'for (int x = 0; x < $size; x++) {\n'
      'int index = y * $size + x;\n'
      'row += ((mask >> index) & 1) + " ";\n'
      '}\n'
      'System.out.println(row);\n'
      '}\n'
      'System.out.println("");\n'
      '}\n'
      '}\n';
  '\n}';

  final StringBuffer genBaseDistanceMap = new StringBuffer();
  genBaseDistanceMap
      .write('private static final int[] baseDistanceMap = new int[]{\n');
  for (int i = 0; i < size * size; i++) {
    genBaseDistanceMap.write('-1, ');
  }
  genBaseDistanceMap.write('};\n');

  final StringBuffer distancesFn = new StringBuffer();

  distancesFn.write(
    'public static int[] getDistancesTo(int targetX, int targetY, long passabilityMask) {\n',
  );
  distancesFn
      .write('long[] reachabilityMasks = new long[${size * size ~/ 2 + 1}];\n');
  distancesFn.write('long reachableMask = 1 << (targetY * $size + targetX);\n');
  distancesFn.write('long prevReachableMask = reachableMask;\n');

  distancesFn.write('for (int i = 0;;i++){\n');
  distancesFn.write('\n// Convolve horizontally\n');
  distancesFn.write('long convolvedHorizontally = reachableMask;');
  distancesFn.write('long mask = 0;\n');

  for (int col = 0; col < size; col++) {
    final int kernel =
        col == 0 || col == size - 1 ? horizontalEdgeKernel : horizontalKernel;

    for (int row = 0; row < size; row++) {
      distancesFn.write(
        'mask = ${kernel} & (reachableMask >> ${row * size + col - (col == 0 ? 0 : 1)});',
      );
      final String mask = '(mask | (mask >> 1) | (mask >> 2) & 1)';
      distancesFn.write(
        'convolvedHorizontally |= ($mask << ${row * size + col});',
      );
      distancesFn.write(' // X: $col, Y: $row\n');
    }
  }
  distancesFn.write(';\n');

  distancesFn.write('\n// Convolve vertically\n');
  distancesFn.write('long convolved = ');
  for (int row = 0; row < size; row++) {
    final int kernel =
        row == 0 || row == size - 1 ? verticalEdgeKernel : verticalKernel;

    for (int col = 0; col < size; col++) {
      final String val =
          '(${kernel} & (convolvedHorizontally >> ${row * size + col - (row == 0 ? 0 : size)}))';
      final String mask =
          '(($val & 1) | ($val >> $size) | ($val >> ${size * 2}) & 1)';
      distancesFn.write(
          '${row > 0 || col > 0 ? '| ' : ''} ($mask << ${row * size + col})');
      distancesFn.write(' // X: $col, Y: $row\n');
    }
  }
  distancesFn.write(';\n');

  // distancesFn.write('printMask(convolved);\n');
  distancesFn.write('\nreachableMask = convolved & passabilityMask;\n');

  distancesFn.write('if (reachableMask == prevReachableMask) {\n');
  distancesFn.write('break;\n');
  distancesFn.write('}\n');

  distancesFn.write('reachabilityMasks[i] = reachableMask;\n');
  distancesFn.write('prevReachableMask = reachableMask;\n');
  distancesFn.write('\n}');

  distancesFn.write('// Find pathing distances\n');
  for (int i = 0; i < size * size ~/ 2 + 1; i++) {
    distancesFn.write('long rm$i = reachabilityMasks[$i];\n');
  }
  distancesFn.write('\n\nint[] pathingDistances = baseDistanceMap.clone();\n');
  for (int i = 0; i < size * size; i++) {
    for (int j = 0; j < size * size ~/ 2 + 1; j++) {
      if (j > 0) {
        distancesFn.write('else ');
      }
      final int mask = 1 << i;
      distancesFn.write(
        '''if ((rm$j & $mask) == $mask) {\n''',
      );
      distancesFn.write('pathingDistances[$i] = ${j + 1};\n');
      distancesFn.write('}\n');
    }
    distancesFn.write('\n');
  }

  distancesFn.write('pathingDistances[targetY * $size + targetX] = 0;\n');
  distancesFn.write('return pathingDistances;\n');
  distancesFn.write('}');

  file.writeAsStringSync(
    template
        .replaceFirst('<GET_DISTANCES_FN/>', distancesFn.toString())
        .replaceFirst('<BASE_DISTANCE_MAP/>', genBaseDistanceMap.toString()),
  );
}

void runExample() {
  int input = int.parse(baseMap, radix: 2);
  int prev = input;

  final List<int> passabilityMaps = [];

  while (true) {
    final int convolved = convolve2(getPaddedBinary(input));
    final int passabilityMask = int.parse(reachabilityMaskstr, radix: 2);
    input = convolved & passabilityMask;

    if (input == prev) {
      break;
    }

    printMap(input);
    printMap(input ^ prev);
    prev = input;
    passabilityMaps.add(input);
  }

  final List<int> pathingDistances = List.filled(size * size, -1);
  for (int i = 0; i < pathingDistances.length; i++) {
    for (int j = 0; j < passabilityMaps.length; j++) {
      if ((passabilityMaps[j] >> size * size - 1 - i) & 1 == 1) {
        pathingDistances[i] = j + 1;
        break;
      }
    }
  }

  for (int y = 0; y < size; y++) {
    final List<String> row = [];
    for (int x = 0; x < size; x++) {
      final int index = y * size + x;
      if (pathingDistances[index] < 10 && pathingDistances[index] >= 0) {
        row.add(' ');
      }
      row.add(pathingDistances[index].toString() + ' ');
    }
    print(row.join(''));
  }
}

List<int> getBestPaths(int fromX, int fromY, List<int> passabilityMaps) {
  int currentDistance = 0;
  int currentPosition = 1 << fromY * size + fromX;
  List<int> bestPaths = [];

  for (int i = 0; i < passabilityMaps.length; i++) {
    if (passabilityMaps[i] & currentPosition == currentPosition) {
      currentDistance = i;
      break;
    }
  }

  int left = currentPosition << 1;
  if (passabilityMaps[currentDistance + 1] & left == left) {
    bestPaths.add(left);
  }

  int right = currentPosition >> 1;
  if (passabilityMaps[currentDistance + 1] & right == right) {
    bestPaths.add(right);
  }

  int top = currentPosition << size;
  if (passabilityMaps[currentDistance + 1] & top == top) {
    bestPaths.add(top);
  }

  int bottom = currentPosition >> size;
  if (passabilityMaps[currentDistance + 1] & bottom == bottom) {
    bestPaths.add(bottom);
  }

  int topLeft = top << 1;
  if (passabilityMaps[currentDistance + 1] & topLeft == topLeft) {
    bestPaths.add(topLeft);
  }

  int topRight = top >> 1;
  if (passabilityMaps[currentDistance + 1] & topRight == topRight) {
    bestPaths.add(topRight);
  }

  int bottomLeft = bottom << 1;
  if (passabilityMaps[currentDistance + 1] & bottomLeft == bottomLeft) {
    bestPaths.add(bottomLeft);
  }

  return bestPaths;
}

void printMap(int input) {
  final String binaryInput = getPaddedBinary(input);

  for (int i = 0; i < size; i++) {
    print(binaryInput.substring(i * size, i * size + size));
  }
  print("");
}

void runExample2() {
  int input = int.parse(baseMap, radix: 2);
  int prev = input;

  while (true) {
    final int convolved = convolve2(getPaddedBinary(input));
    // final int passabilityMask = int.parse(reachabilityMaskstr, radix: 2);
    input = convolved;

    if (input == prev) {
      break;
    }

    // printMap(input);
    prev = input;
  }
}

int convolve2(String binaryInput) {
  final int input = int.parse(binaryInput, radix: 2);

  int restorationMaskLeft = 0;
  int restorationMaskRight = 0;

  for (int i = 1; i < size; i++) {
    restorationMaskLeft |= 1 << (i * size);
    restorationMaskRight |= 1 << ((i - 1) * size + size - 1);
  }

  restorationMaskLeft =
      restorationMaskLeft ^ int.parse(baseMap.replaceAll("0", "1"), radix: 2);
  restorationMaskRight =
      restorationMaskRight ^ int.parse(baseMap.replaceAll("0", "1"), radix: 2);

  int output = 0;
  print(getPaddedBinary(restorationMaskLeft));
  print(getPaddedBinary(restorationMaskRight));
  print(getPaddedBinary(input << 1));
  print(getPaddedBinary(input >> 1));

  output = input |
      (restorationMaskLeft & (input << 1)) |
      (restorationMaskRight & (input >> 1));

  int restorationMaskTop = int.parse(baseMap.replaceAll("0", "1"), radix: 2);
  int restorationMaskBottom = int.parse(baseMap.replaceAll("0", "1"), radix: 2);

  output = output |
      (restorationMaskTop & (output << size)) |
      (restorationMaskBottom & (output >> size));

  // output |= input | input << 1;
  // output |= input | input >> 1;

  // for (int row = 0; row < size; row++) {
  //   final int shifted = input >> (row * size) & 0x7f;
  //   output |= (((shifted | shifted << 1) | (shifted | shifted >> 1)) & 0x7f) <<
  //       (row * size);
  //   print(getPaddedBinary(shifted));
  //   print(getPaddedBinary(shifted << 1));
  //   print(getPaddedBinary(shifted >> 1));
  // }

  printMap(output);

  // for (int row = 0; row < size; row++) {
  //   for (int col = 0; col < size; col++) {
  //     final int kernel = col == 0 || col == size - 1 ? 1 : 2;

  //     final int kernelMask =
  //         (kernel << (row * size + col - (col == 0 ? 0 : 1)));
  //     // print(col.toString() + ":" + row.toString());
  //     // print(getPaddedBinary(input));
  //     // print(getPaddedBinary(kernelMask));
  //     // print(getPaddedBinary(input & kernelMask));
  //     if (col < size - 1) {
  //       output |= input | (input << 1);
  //       // print(getPaddedBinary(output));
  //     }
  //     if (col > 0) {
  //       output |= input | (input >> 1);
  //       // output |= input | ((kernelMask & input) >> 1);
  //       // print(getPaddedBinary(output));
  //     }
  //     printMap(output);
  //   }
  // }

  return output;
}

int convolve(String binaryInput) {
  final int input = int.parse(binaryInput, radix: 2);
  int output = 0;

  // Convolve horizontally
  for (int col = 0; col < size; col++) {
    final int kernel =
        col == 0 || col == size - 1 ? horizontalEdgeKernel : horizontalKernel;

    for (int row = 0; row < size; row++) {
      final int val =
          kernel & (input >> (row * size + col - (col == 0 ? 0 : 1)));
      // final int mask = ((val & 1) | (val >> 1 & 1) | (val >> 2 & 1));
      final int mask = val | (val >> 1) | (val >> 2) & 1;
      output |= mask << (row * size + col);
    }
  }

  // Convolve vertically
  for (int row = 0; row < size; row++) {
    final int kernel =
        row == 0 || row == size - 1 ? verticalEdgeKernel : verticalKernel;

    for (int col = 0; col < size; col++) {
      final int shifted = input >> (row * size + col - (row == 0 ? 0 : size));
      final int val = kernel & shifted;
      // final int mask =
      //     ((val & 1) | (val >> size & 1) | (val >> (size * 2) & 1));
      final int mask = val | (val >> size) | (val >> (size * 2)) & 1;
      output |= (mask & 1) << (row * size + col);
    }
  }

  return output;
}

String getPaddedBinary(int number) {
  final String binary = number.toRadixString(2);
  final int padding = size * size - binary.length;

  return '0' * padding + binary;
}
